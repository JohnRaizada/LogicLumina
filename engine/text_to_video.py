# -*- coding: utf-8 -*-
"""text_to_video

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eeN1eM5YatX0JW_Fr3z0nzNm4gZSS5Xi

Language Choice
"""

Languages=['Afrikaans', 'Albanian', 'Amharic', 'Arabic', 'Armenian', 'Bengali', 'Bosnian', 'Catalan', 'Croatian', 'Czech',
'Danish', 'Dutch', 'English', 'Esperanto', 'Estonian', 'Filipino', 'Finnish', 'French', 'German', 'Greek', 'Gujarati',
'Haitian Creole', 'Hebrew', 'Hindi', 'Hungarian', 'Icelandic', 'Indonesian', 'Italian', 'Japanese', 'Javanese',
'Kannada', 'Khmer', 'Korean', 'Latin', 'Latvian', 'Lithuanian', 'Macedonian', 'Malay', 'Malayalam', 'Marathi',
'Burmese', 'Nepali', 'Norwegian', 'Polish', 'Portuguese', 'Punjabi', 'Romanian', 'Russian', 'Serbian', 'Sinhalese',
'Slovak', 'Slovenian', 'Spanish', 'Sundanese', 'Swahili', 'Swedish', 'Tamil', 'Telugu', 'Thai', 'Turkish', 'Ukrainian',
'Urdu', 'Vietnamese', 'Welsh', 'Xhosa', 'Yiddish', 'Zulu', 'Azerbaijani', 'Basque', 'Belarusian', 'Chichewa',
'Chinese', 'Corsican', 'Cebuano', 'Chinese (simplified)', 'Chinese (traditional)', 'Galician', 'Georgian', 'Hausa',
'Hawaiian', 'Hmong', 'Persian', 'Igbo', 'Irish', 'Japanese', 'Kazakh', 'Kurdish (kurmanji)', 'Kyrgyz', 'Lao',
'Latin', 'Latvian', 'Lithuanian', 'Luxembourgish', 'Macedonian', 'Malagasy', 'Malay', 'Maltese', 'Maori', 'Mongolian',
'Myanmar (Burmese)', 'Pashto', 'Polish', 'Portuguese', 'Russian', 'Samoan', 'Scots Gaelic', 'Serbian', 'Sesotho', 'Shona',
'Sindhi', 'Sinhala', 'Somali', 'Uzbek', 'Tajik', 'Telugu', 'Turkish', 'Ukrainian', 'Uyghur', 'Yoruba', 'Zulu']

def get_language():
    lang=input('Choose from above Languages')
    lang=lang.lower()
    return lang
def set_language():
  # lang= get_language()
  return lang

"""Input Choice"""

def choose_opt():
  print("Menu:\n1. Bus\n2. Train")
  choice=int(input("Select from 1 and 2 "))
  return choice

"""Text-to-Speech"""

!pip install gTTs

from gtts import gTTS
import os

def text_to_speech(text, language, file_name='output.mp3', tld='co.in'):
    tts = gTTS(text=text, lang=language, slow=False)
    tts.save(file_name)
    return file_name

# Dictionary mapping languages to GTTS language codes
language_dict = {
    'afrikaans': 'af',
    'albanian': 'sq',
    'amharic': 'am',
    'arabic': 'ar',
    'armenian': 'hy',
    'azerbaijani': 'az',
    'basque': 'eu',
    'belarusian': 'be',
    'bengali': 'bn',
    'bosnian': 'bs',
    'bulgarian': 'bg',
    'catalan': 'ca',
    'cebuano': 'ceb',
    'chichewa': 'ny',
    'chinese': 'zh-CN',
    'chinese (simplified)': 'zh-CN',
    'chinese (traditional)': 'zh-TW',
    'corsican': 'co',
    'croatian': 'hr',
    'czech': 'cs',
    'danish': 'da',
    'dutch': 'nl',
    'english': 'en',
    'esperanto': 'eo',
    'estonian': 'et',
    'filipino': 'tl',
    'finnish': 'fi',
    'french': 'fr',
    'frisian': 'fy',
    'galician': 'gl',
    'georgian': 'ka',
    'german': 'de',
    'greek': 'el',
    'gujarati': 'gu',
    'haitian creole': 'ht',
    'hausa': 'ha',
    'hawaiian': 'haw',
    'hebrew': 'iw',
    'hindi': 'hi',
    'hmong': 'hmn',
    'hungarian': 'hu',
    'icelandic': 'is',
    'igbo': 'ig',
    'indonesian': 'id',
    'irish': 'ga',
    'italian': 'it',
    'japanese': 'ja',
    'javanese': 'jw',
    'kannada': 'kn',
    'kazakh': 'kk',
    'khmer': 'km',
    'korean': 'ko',
    'kurdish (kurmanji)': 'ku',
    'kyrgyz': 'ky',
    'lao': 'lo',
    'latin': 'la',
    'latvian': 'lv',
    'lithuanian': 'lt',
    'luxembourgish': 'lb',
    'macedonian': 'mk',
    'malagasy': 'mg',
    'malay': 'ms',
    'malayalam': 'ml',
    'maltese': 'mt',
    'maori': 'mi',
    'marathi': 'mr',
    'mongolian': 'mn',
    'myanmar (burmese)': 'my',
    'nepali': 'ne',
    'norwegian': 'no',
    'odia': 'or',
    'pashto': 'ps',
    'persian': 'fa',
    'polish': 'pl',
    'portuguese': 'pt',
    'punjabi': 'pa',
    'romanian': 'ro',
    'russian': 'ru',
    'samoan': 'sm',
    'scots gaelic': 'gd',
    'serbian': 'sr',
    'sesotho': 'st',
    'shona': 'sn',
    'sindhi': 'sd',
    'sinhala': 'si',
    'slovak': 'sk',
    'slovenian': 'sl',
    'somali': 'so',
    'spanish': 'es',
    'sundanese': 'su',
    'swahili': 'sw',
    'swedish': 'sv',
    'tajik': 'tg',
    'tamil': 'ta',
    'telugu': 'te',
    'thai': 'th',
    'turkish': 'tr',
    'ukrainian': 'uk',
    'urdu': 'ur',
    'uyghur': 'ug',
    'uzbek': 'uz',
    'vietnamese': 'vi',
    'welsh': 'cy',
    'xhosa': 'xh',
    'yiddish': 'yi',
    'yoruba': 'yo',
    'zulu': 'zu'
}

# Function to get GTTS language code for a given language
def get_gtts_code(language):
    return language_dict.get(language.lower(), 'en')  # Default to 'en' (English) if the language is not found

"""Dictionary"""

arrive=['arrive','come',]
depart=['depart', 'leave', 'go']
clean=[]
helpline=[]
safe=['safe','safety']

"""Translate text"""

pip install googletrans==4.0.0-rc1

from googletrans import Translator

def auto_translate_to_english(text):
    translator = Translator()
    translation = translator.translate(text, dest='en')
    return translation.text
'''text=input("Enter Text")
trans=auto_translate_to_english(text)
trans'''

"""Setting Folder Path"""

'''
from google.colab import drive

# Mount Google Drive
drive.mount('/content/drive')

# Create a new folder in Google Drive
folder_name = 'Text to Video'
folder_path = '/content/drive/MyDrive/' + folder_name

try:
    os.makedirs(folder_path)
    print(f"Folder '{folder_name}' created successfully in Google Drive.")
except FileExistsError:
    print(f"Folder '{folder_name}' already exists in Google Drive.")

# You can now use the 'folder_path' variable to reference the path to your new folder.
'''

"""Function to Display Video"""

import cv2

# Assuming you have a function to display a video
def display_video(video_path):
    # Your video display logic here
    # For example, using OpenCV
    cap = cv2.VideoCapture(video_path)

    while cap.isOpened():
        ret, frame = cap.read()

        if not ret:
            break

        # Display the frame
        cv2.imshow('Video Display', frame)

        # Break the loop if 'q' is pressed
        if cv2.waitKey(25) & 0xFF == ord('q'):
            break

    cap.release()
    cv2.destroyAllWindows()

"""Choosing a random Video"""

import os
import random
def choose_random_video(folder_path):
    # Check if the path is a directory
    if not os.path.isdir(folder_path):
        print("Error: The specified path is not a directory.")
        return None

    # Get a list of all files in the directory
    video_files = [f for f in os.listdir(folder_path) if os.path.isfile(os.path.join(folder_path, f))]

    # Check if there are any video files
    if not video_files:
        print("Error: No video files found in the specified folder.")
        return None

    # Choose a random video file
    random_video = random.choice(video_files)

    # Construct the full path to the chosen video
    video_path = os.path.join(folder_path, random_video)

    return video_path

"""Generate Video"""

def generate_vid():
  final_eng= english_translation.lower().split()
  if choice == 1:
    for i in final_eng:
      if i in arrive:
        folder_path='/content/drive/MyDrive/Text to Video/Arrive-Bus'
        video_path = choose_random_video(folder_path)
        return video_path
      elif i in depart:
        folder_path='/content/drive/MyDrive/Text to Video/Depart- Bus'
        video_path = choose_random_video(folder_path)
        # Call the function to display the video
        return video_path
      elif i in clean:
        folder_path='/content/drive/MyDrive/Text to Video/Cleanliness'
        video_path = chosoe_random_video(folder_path)
        # Call the function to display the video
        return video_path
      elif i in safe:
        folder_path='/content/drive/MyDrive/Text to Video/Safe'
        video_path = choose_random_video(folder_path)
        # Call the function to display the video
        return video_path
      elif i in helpline:
        folder_path='/content/drive/MyDrive/Text to Video/Helpline Numbers'
        video_path = choose_random_video(folder_path)
        # Call the function to display the video
        return video_path
  elif choice == 2:
    for i in final_eng:
      if i in arrive:
        folder_path="/content/drive/MyDrive/Text to Video/Arrival- Train"
        video_path = choose_random_video(folder_path)
        # Call the function to display the video
        return video_path
      elif i in depart:
        folder_path="/content/drive/MyDrive/Text to Video/Dparture- Train"
        video_path = choose_random_video(folder_path)
        # Call the function to display the video
        return video_path
      elif i in clean:
        folder_path='/content/drive/MyDrive/Text to Video/Cleanliness'
        video_path = choose_random_video(folder_path)
        # Call the function to display the video
        return video_path
      elif i in safe:
        folder_path='/content/drive/MyDrive/Text to Video/Safe'
        video_path = choose_random_video(folder_path)
        # Call the function to display the video
        return video_path
      elif i in helpline:
        folder_path='/content/drive/MyDrive/Text to Video/Helpline Numbers'
        video_path = choose_random_video(folder_path)
        # Call the function to display the video
        return video_path
  else:
    print('invalid choice')

!pip install pydub

from pydub import AudioSegment
from moviepy.video.io.VideoFileClip import VideoFileClip
from moviepy.video.io.ffmpeg_tools import ffmpeg_extract_subclip
import os

def get_audio_length(audio_file_path):
    audio = AudioSegment.from_file(audio_file_path)
    return len(audio) / 1000  # Convert milliseconds to seconds

def cut_video_to_audio_length(video_file_path, audio_length):
    output_file_path='/content/output.mp4'
    extra_seconds = 2 # Adjust this value as needed
    video = VideoFileClip(video_file_path)

    # Ensure the video is at least 4 seconds longer than the audio
    if video.duration < audio_length + extra_seconds:
        extra_seconds = max(0, audio_length - video.duration)

    start_time = 0
    end_time = min(video.duration, audio_length + extra_seconds)

    ffmpeg_extract_subclip(video_file_path, start_time, end_time, targetname=output_file_path)
    return output_file_path

"""Concat Video and Audio"""

from moviepy.editor import VideoFileClip, AudioFileClip, concatenate_videoclips
import os
def concat():
  # Open the video and audio
  video_file=cut_video_to_audio_length(generate_vid(),audio_length)
  video_clip = VideoFileClip(video_file)
  audio_clip = AudioFileClip(file_name)
  # Concatenate the video clip with the audio clip
  final_clip = video_clip.set_audio(audio_clip)
  # Export the final video with audio
  final_clip.write_videofile("output_final.mp4")

"""Final Code"""

print(Languages)
lang = get_language()
# lang=set_language()
Text=input("Enter Text")
choice=choose_opt()
language=get_gtts_code(lang)
file_name=text_to_speech(Text,language)
english_translation=auto_translate_to_english(Text)
audio_length=get_audio_length(file_name)
concat()